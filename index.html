<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Listen → Answer → Grade</title>
<style>
  body{font:16px/1.6 system-ui,sans-serif;max-width:780px;margin:24px auto;padding:0 16px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  button{padding:10px 16px;border-radius:999px;border:1px solid #ddd;cursor:pointer}
  #live{opacity:.6;white-space:pre-wrap;margin-top:8px}
  #final{white-space:pre-wrap;margin-top:8px}
  #score{font-weight:700;margin-top:12px}
  .ok{color:#0a7a0a}.ng{color:#c01818}
  #q{font-size:18px;margin:6px 0 12px}
</style>

<h2>Question</h2>
<div id="q"></div>
<div class="row">
  <button id="play">🔊 Play</button>
  <button id="rec">🎤 Start</button>
  <button id="grade">✅ Grade</button>
</div>

<div id="live"></div>
<div id="final"></div>
<div id="score"></div>

<script>
/* ====== ここから置換 ====== */
const SHEET_CSV =
  'https://docs.google.com/spreadsheets/d/e/2PACX-1vRVC56sLRh94LTed5WD4sVkIojw00CTlBL7yPtJocPewWqQ-ODfFsmLx_k9BX3LOmNT8ztP4GwqJVfl/pub?gid=0&single=true&output=csv';

let QUESTION_TEXT = 'Loading...';
let ANSWER_KEY = '';
const STT_API = '/api/transcribe';

async function loadSheet() {
  const csv = await (await fetch(SHEET_CSV, { cache: 'no-store' })).text();
  // カンマ(ダブルクオート内は除外)で分割
  const rows = csv.trim().split(/\r?\n/).map(
    line => line.match(/("([^"]|"")*"|[^,]*)/g)
                 .filter(s => s !== '')
                 .map(s => s.replace(/^"|"$/g,'').replace(/""/g,'"'))
  );
  const header = rows[0].map(h => h.trim().toLowerCase());
  const qi = header.indexOf('question');
  const ai = header.indexOf('answer');
  if (qi < 0 || ai < 0 || rows.length < 2) {
    throw new Error('Sheet must have "Question" and "Answer" columns with at least 1 row');
  }
  const first = rows[1];                // 先頭のデータ行を使用（必要なら行を変えてください）
  QUESTION_TEXT = first[qi] || '';
  ANSWER_KEY = (first[ai] || '').toLowerCase();

  document.getElementById('q').textContent = QUESTION_TEXT;
}
loadSheet().catch(e => {
  document.getElementById('q').textContent = 'Load error: ' + e.message;
});
/* ====== 置換ここまで ====== */

/* ====== 出題表示 ====== */
document.getElementById('q').textContent = QUESTION_TEXT;

/* ====== TTS（Web Speech API） ====== */
const playBtn = document.getElementById('play');
playBtn.onclick = () => {
  const u = new SpeechSynthesisUtterance(QUESTION_TEXT);
  // 英語で出題する想定（日本語化したい場合は 'ja-JP'）
  u.lang = 'en-US';
  speechSynthesis.cancel();
  speechSynthesis.speak(u);
};

/* ====== 暫定字幕 + 録音 → Whisper ====== */
let stream, rec, chunks=[], timer, recognizing=false, recog;
const live = document.getElementById('live');
const finalEl = document.getElementById('final');
const scoreEl = document.getElementById('score');
let confirmed = '';   // Whisperの確定テキストを蓄積
let interim   = '';   // 暫定字幕

const recBtn = document.getElementById('rec');
recBtn.onclick = async ()=>{ if(!rec || rec.state==='inactive') start(); else stop(); };

async function start(){
  scoreEl.textContent = '';
  confirmed = interim = '';
  finalEl.textContent = ''; live.textContent = '';

  // 暫定字幕（ブラウザ内）
  if('webkitSpeechRecognition'in window || 'SpeechRecognition'in window){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    recog = new SR();
    recog.lang = 'en-US';            // ←英語練習。日本語にしたい時は 'ja-JP'
    recog.interimResults = true;
    recog.continuous = true;
    recog.onresult = e=>{
      let tmp='';
      for(let i=e.resultIndex;i<e.results.length;i++){
        const r=e.results[i];
        if(r.isFinal){ confirmed += (r[0].transcript + '\n'); }
        else{ tmp += r[0].transcript; }
      }
      interim = tmp;
      live.textContent = interim;
      finalEl.textContent = confirmed;
    };
    try{ recog.start(); recognizing=true; }catch{}
  }

  // 録音（3秒ごとにWhisperへ）
  stream = await navigator.mediaDevices.getUserMedia({audio:true});
  const mime = MediaRecorder.isTypeSupported('audio/webm')?'audio/webm':'audio/ogg';
  rec = new MediaRecorder(stream,{mimeType:mime});
  chunks=[];
  rec.ondataavailable=e=>{ if(e.data&&e.data.size) chunks.push(e.data); };
  rec.start();

  timer = setInterval(sendChunk, 3000);
  recBtn.textContent = '🟥 Stop';
}

async function stop(){
  clearInterval(timer);
  if(rec && rec.state!=='inactive') rec.stop();
  if(stream) stream.getTracks().forEach(t=>t.stop());
  if(recognizing && recog){ try{ recog.stop(); }catch{} }
  recBtn.textContent='🎤 Start';
  if(chunks.length) await sendChunk(); // 残りを送信
}

function toBase64(blob){
  return new Promise((res,rej)=>{
    const r=new FileReader();
    r.onloadend=()=>res(r.result);
    r.onerror=rej;
    r.readAsDataURL(blob);
  });
}

async function sendChunk(){
  if(!chunks.length) return;
  const blob = new Blob(chunks.splice(0, chunks.length), { type: rec.mimeType });
  const b64 = await toBase64(blob);
  const r = await fetch(STT_API,{method:'POST',headers:{'content-type':'application/json'},
    body: JSON.stringify({ base64: b64.split(',')[1], mime: rec.mimeType, language: 'en' })});
  const j = await r.json().catch(()=>({}));
  if(j && j.text){ confirmed += j.text + '\n'; finalEl.textContent = confirmed; }
}

/* ====== 採点 ====== */
const gradeBtn = document.getElementById('grade');
gradeBtn.onclick = ()=>{
  const cand = normalize((confirmed || interim || '').trim());
  const gold = normalize(ANSWER_KEY);
  const sim = similarity(cand, gold);   // 0〜1
  const ok  = sim >= 0.85;              // しきい値（必要なら調整）
  scoreEl.className = ok ? 'ok' : 'ng';
  scoreEl.textContent = ok
    ? `✔ Correct (similarity ${Math.round(sim*100)}%)`
    : `✖ Try again (similarity ${Math.round(sim*100)}%)\nYour answer: ${cand}\nExpected: ${gold}`;
};

function normalize(s){
  return s.toLowerCase()
    .replace(/[^\p{Letter}\p{Number}\s]/gu,'') // 記号除去
    .replace(/\s+/g,' ')
    .trim();
}

// レーベンシュタイン距離→類似度
function similarity(a,b){
  const m=a.length,n=b.length;
  if(!m && !n) return 1;
  const dp=Array.from({length:m+1},(_,i)=>[i]);
  for(let j=1;j<=n;j++) dp[0][j]=j;
  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const cost = a[i-1]===b[j-1]?0:1;
      dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
    }
  }
  const dist=dp[m][n];
  const maxLen=Math.max(m,n);
  return 1 - dist/maxLen;
}
</script>
